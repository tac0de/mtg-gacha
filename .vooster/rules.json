{
  "rules": [
    {
      "type": "prd",
      "content": "# Product Requirements Document\n\n## 1. Executive Summary  \nBuild “MTG Gacha” – a mobile app and mobile web platform (Capacitor-based for app) that lets Magic: The Gathering players buy digital gacha packs, convert obtained cards into in-app points, and redeem merchandise or additional packs. The service offers a legal, engaging, and convenient way to enjoy randomized card acquisition while driving recurring revenue through micro-transactions.\n\n## 2. Problem Statement  \n• Physical MTG boosters are costly, hard to access instantly, and limit trading options.  \n• Existing digital MTG platforms focus on gameplay, not collection gacha.  \n• Players lack a trusted, transparent system to convert surplus digital cards into tangible rewards.\n\n## 3. Goals and Objectives  \nPrimary Goal  \n– Deliver a seamless gacha experience that converts card pulls into redeemable value.  \n\nSecondary Goals  \n– Increase user engagement via collection management and AI suggestions.  \n– Provide cross-platform accessibility (iOS/Android mobile apps and mobile web).  \n– Generate sustainable revenue through in-app purchases.  \n\nSuccess Metrics  \n– D1, D7, D30 retention ≥ 35 / 25 / 15 %.  \n– 5 % conversion to paying users within 30 days.  \n– Average revenue per paying user (ARPPU) ≥ USD 15/month.  \n– 99 % transaction success rate, < 0.5 % fraud.  \n\n## 4. Target Audience  \nPrimary Users  \n– MTG players aged 18-40, tech-savvy, casual to competitive, interested in collecting rare cards.  \n\nSecondary Users  \n– Merchandising partners, tournament organizers, content creators who benefit from increased MTG engagement.\n\n## 5. User Stories  \n– As a collector, I want to buy a gacha pack with one tap so that I instantly see new cards.  \n– As a budget player, I want to convert duplicate cards to points so that I can buy items I actually need.  \n– As a merch hunter, I want to redeem points for exclusive playmats so that I stand out at events.  \n– As a new user, I want social login so that onboarding is frictionless.  \n– As a power user, I want deck suggestions based on my collection so that I optimize gameplay.  \n\n## 6. Functional Requirements  \n\n### Core Features  \n\n1. Gacha Pack Purchase  \n   – Randomized card draw following official rarity ratios.  \n   – Payment gateways: Stripe (web), Apple/Google IAP (mobile).  \n   – Animation with skip option.  \n   – Acceptance: 100 % randomness audit; purchase ≤ 3 s latency; refund flow supported.\n\n2. Point Conversion Engine  \n   – Automatic conversion of selected cards to “Mana Points.”  \n   – Conversion rates vary by rarity.  \n   – Real-time balance update.  \n   – Acceptance: balance accuracy ±0; audit log available.\n\n3. Merchandise & Digital Store  \n   – Catalog of physical goods (playmats, sleeves) and digital goods (premium avatars).  \n   – Inventory, shipping address management, tax/VAT handling.  \n   – Acceptance: checkout ≤ 4 steps; confirmation email within 1 min.\n\n4. Collection Management  \n   – Grid & list views, filters by color, set, rarity.  \n   – Share collection via URL or QR.  \n   – Acceptance: load ≤ 1 s for 1 k cards; share link valid 30 days.\n\n5. User Account & Authentication  \n   – Email/pass, Google, Apple, and Discord login.  \n   – 2FA optional.  \n   – Acceptance: session expiry 30 days; OWASP compliance.\n\n6. Payment & Wallet  \n   – Multi-currency support, localize prices.  \n   – Transaction history, receipts.  \n   – Acceptance: PCI-DSS Level 1; dispute rate < 0.3 %.\n\n### Supporting Features  \n– AI Recommendation: suggest packs/decks based on collection.  \n– Push Notifications: drop alerts, shipping updates.  \n– Referral Program: codes grant bonus points.  \n– Admin Dashboard: manage inventory, audit logs.  \n\n## 7. Non-Functional Requirements  \nPerformance: 95th percentile API < 300 ms, page LCP < 2.5 s.  \nSecurity: JWT auth, TLS 1.3, GDPR/CCPA compliance, encryption at rest.  \nUsability: WCAG 2.1 AA, intuitive UI across devices.  \nScalability: 1 k → 100 k DAU via autoscaling.  \nCompatibility: iOS 14+, Android 10+, major mobile browsers (Chrome, Safari).\n\n## 8. Technical Considerations  \nArchitecture:  \n– Front-end: Capacitor-based native mobile app for iOS and Android, responsive mobile web (Next.js or equivalent).\n– Back-end: Supabase (Postgres, Auth), Node micro-services for gacha engine.  \n– CDN for assets (Cloudflare).  \nIntegrations:  \n– Wizards of the Coast card API for card metadata.  \n– Stripe, Apple Pay, Google Pay.  \n– SendGrid for transactional email.  \nData:  \n– Card pulls, point balances, inventory, user analytics stored in Postgres.  \n– Daily backup, 30-day retention.  \nThird-Party:  \n– Analytics (PostHog), Crashlytics, Sentry.  \n\n## 9. Success Metrics and KPIs  \nProduct: MAU, retention cohorts, session length.  \nBusiness: Gross Merchandise Volume (GMV), ARPPU, LTV/CAC ratio ≥ 3.  \nTechnical: API error rate < 0.2 %, uptime 99.9 %.  \n\n## 10. Timeline and Milestones  \nPhase 1 – UI/Frontend Focus (Day 1-2)\n– Build and validate core UI screens and interactive flows (purchase, collection, login) using placeholder/mock data. Ensure responsive and intuitive user experience across web and mobile.\nPhase 2 – Backend Integration (Day 3-5)\n– Connect frontend to backend services (gacha engine, authentication, point system). Implement real data flows, APIs, and transaction logic.\nPhase 3 – Beta and GA (Day 6-7)\n– Enable social login, merchandise store, AI recommendations, referral, push notifications, advanced analytics, and regional expansions.\n## 11. Risks and Mitigation  \nTechnical: Randomization fairness → use verifiable RNG & third-party audit.  \nBusiness: IP licensing with Wizards → secure legal agreement early.  \nUser Adoption: Paywall fatigue → offer free daily pack to drive engagement.  \nSecurity: Fraud & chargebacks → implement fraud scoring and velocity checks.  \n\n## 12. Future Considerations  \n– P2P trading marketplace with escrow.  \n– Blockchain verifiable ownership (opt-in).  \n– Tournament integration with prize payouts.  \n– Localization: Japanese, Korean, Spanish.",
      "writedAt": "2025-07-07T09:45:16.751Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 문서 (TRD)\n\n## 1. 기술 총괄 개요\n- **프로젝트 개요**  \n  “MTG Gacha” 모바일 앱·모바일 웹 플랫폼은 Capacitor 기반 단일 코드베이스(모노레포)로 구축되며, Supabase(PostgreSQL) + Node.js(Micro-Service) 조합을 활용해 카드 뽑기, 결제, 포인트 전환, 굿즈 교환 기능을 제공한다.\n- **핵심 기술 스택**  \n  - 프런트엔드: Next.js 14 (React 18, TypeScript) + Capacitor 5  \n  - 백엔드: Supabase 2.0(PostgreSQL 15, Supabase Auth/Edge Functions) + Node.js 20(Express)  \n  - 인프라: Vercel(웹 호스팅) / Supabase(데이터·Auth) / Fly.io(Node 마이크로서비스) / Cloudflare CDN  \n- **주요 기술 목표**  \n  1. 95퍼센타일 API 응답 < 300 ms  \n  2. 트랜잭션 성공률 99 % 이상, 결제 사기 < 0.3 %  \n  3. 100k DAU까지 수평 확장 가능  \n- **중대한 기술 가정**  \n  - Supabase의 Row-Level Security로 데이터 보호 가능  \n  - Vercel + Edge Function 구조로 LCP 2.5 s 이하 달성  \n  - 결제 비즈니스 로직은 Stripe · Apple/Google IAP · Toss Payments SDK로 분리\n\n## 2. 기술 스택 아키텍처\n### 프런트엔드 기술 스택\n- **코어 프레임워크**: Next.js 14 (App Router, React Server Components 적용)  \n- **상태 관리**: React Query 5 + Context API (필요 시 Zustand)  \n- **라우팅 & 내비게이션**: Next.js App Router / React Navigation(Capacitor)  \n- **UI/UX 프레임워크**: Tailwind CSS 3 + Headless UI; 애니메이션은 Framer Motion  \n- **빌드 툴**: Vite 기반 Next.js Turbopack, ESLint, Prettier, Husky(커밋 훅)\n\n### 백엔드 기술 스택\n- **런타임 환경**: Node.js 20 (TypeScript)  \n- **웹 프레임워크**: Express 4 (가볍고 검증된 미들웨어 생태계)  \n- **API 디자인 패턴**: RESTful (JSON); gacha 엔진은 내부 RPC(JSON over HTTPS)  \n- **데이터 검증**: Zod 스키마; Celebrate(Joi) 미들웨어  \n- **미들웨어 구성요소**: morgan(로깅), helmet(보안 헤더), rate-limit(속도 제한), Sentry(Error)\n\n### 데이터베이스 & 퍼시스턴스\n- **주 데이터베이스**: PostgreSQL 15 (Supabase Managed)  \n  - 이유: ACID 보장, JSONB·CTE 지원, Supabase와 기본 통합\n- **스키마 설계**: 3NF+부분 비정규화, 파티셔닝(카드 풀 로그), RLS 적용  \n- **캐싱 전략**: Redis 7 (Fly.io Redis®) – 세션, 빈번한 읽기용 메타데이터 캐시  \n- **데이터 마이그레이션**: Supabase Migrations + Sqitch 버전 관리  \n- **백업 & 복구**: Supabase 자동 스냅샷(1일 1회, 30일 보존) + 외부 S3 주간 백업\n\n### 인프라 & DevOps\n- **호스팅 환경**:  \n  - 웹: Vercel 자동 배포  \n  - 백엔드: Fly.io(프리 리전, 수평 오토스케일)  \n  - 데이터: Supabase 서비-스케일 플랜  \n- **컨테이너라이제이션**: Docker Compose(로컬) + Fly Launch(Dockerfile)  \n- **CI/CD 파이프라인**: GitHub Actions → 테스트 → 빌드 → 배포  \n- **모니터링 & 가시성**: Grafana Cloud(Prometheus), Sentry, PostHog  \n- **로깅 전략**: Cloudflare 로그 + Loki 중앙집중 저장, 로그 레벨 구조화(JSON)\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 빌딩 블록\n- 프런트엔드 (Next.js + Capacitor)  \n  - 모바일 웹, iOS/Android 래퍼  \n- Auth & Gateway (Supabase Auth, Edge Function)  \n  - JWT 발급, 소셜 로그인, RLS 정책  \n- Gacha Service (Node.js Micro-Service)  \n  - 난수 생성, 카드 풀 로직, 감사 로그  \n- Core API (Supabase RPC & REST)  \n  - 포인트, 인벤토리, 상점, 주문  \n- 외부 통합  \n  - Stripe/Apple/Google/Toss 결제, SendGrid 이메일, WoTC 카드 API\n\n### 컴포넌트 상호작용 다이어그램\n```mermaid\ngraph TD\n    A[Next.js/Capacitor 앱] -->|JWT| B[Supabase Edge Gateway]\n    B -->|REST/RPC| C[Core API(PostgreSQL)]\n    B -->|HTTPS| D[Gacha Service(Node)]\n    C --> E[Redis Cache]\n    B -->|Webhook| F[결제 게이트웨이(Stripe/IAP/Toss)]\n```\n- 클라이언트는 JWT 포함 요청으로 Edge Gateway 호출  \n- Gateway는 Postgres 함수 또는 Gacha Service에 라우팅  \n- Postgres는 Redis 캐시를 보조 저장소로 활용  \n- 결제 완료 시 게이트웨이가 Webhook 수신 후 잔액·인벤토리 업데이트\n\n### 코드 구성 & 컨벤션\n**도메인 기반 조직 전략**\n- **Bounded Context**: user, gacha, payment, inventory, store, admin  \n- **계층 분리**: presentation → service → repository → infra  \n- **기능 모듈**: 각 컨텍스트별 Feature 디렉터리  \n- **공용 컴포넌트**: shared/lib, shared/ui, shared/types\n\n**보편적 폴더 구조 트리**\n```\n/mtg-gacha\n├── apps/\n│   ├── web/                # Next.js\n│   └── mobile/             # Capacitor wrapper\n├── services/\n│   └── gacha-engine/       # Node Express microservice\n├── packages/\n│   ├── shared-ui/\n│   ├── shared-lib/\n│   └── types/\n├── database/\n│   ├── migrations/\n│   └── seeds/\n└── infra/\n    ├── docker/\n    ├── github-actions/\n    └── terraform/\n```\n\n### 데이터 흐름 & 통신 패턴\n- **클라이언트-서버 통신**: HTTPS REST, Access Token은 Supabase JWT  \n- **DB 상호작용**: Supabase RPC(Stored Procedure) + Prisma ORM(마이크로서비스)  \n- **외부 서비스 통합**: Stripe SDK, Apple/Google IAP Server API, Toss REST  \n- **실시간 통신**: Supabase Realtime(Channel) → 카드 풀 애니메이션 동기화  \n- **데이터 동기화**: 이벤트 소싱(카드 풀 이벤트) + CDC(Logical Replication)\n\n## 4. 성능 & 최적화 전략\n- 페이지별 Code-Splitting과 이미지 lazy-loading으로 LCP 2.5 s 달성  \n- Postgres 인덱스·파티션·Prepared Statement 적용으로 300 ms 이하 응답 유지  \n- Redis 캐시 TTL 60 s로 인기 카드 메타데이터 응답 가속  \n- Cloudflare CDN + Brotli 압축으로 정적 자산 전송 최적화\n\n## 5. 구현 로드맵 & 마일스톤\n### Phase 1: 기반(MVP 구현) – 4주\n- 인프라 세팅(Vercel, Supabase, Fly.io)  \n- 핵심 화면(로그인, 뽑기, 컬렉션) + Gacha 엔진 v1  \n- Stripe 테스트 결제, Supabase Auth(소셜) 적용  \n- CI/CD 파이프라인, 기본 보안(HTTPS, Helmet)  \n### Phase 2: 기능 확장 – 3주\n- 포인트 전환, 상점/주문, 이메일 영수증  \n- Apple/Google IAP, Toss 결제 연동  \n- 캐시·지표 모니터링, 성능 튜닝  \n### Phase 3: 스케일링 & 최적화 – 4주\n- 자동 확장(플라이 수평 스케일, Supabase 프리미엄 플랜)  \n- AI 추천, 추천인 코드, 푸시 알림  \n- GDPR/CCPA, PCI-DSS 준수 감사 로그  \n- 부하 테스트, 99.9 % 가용성 목표\n\n## 6. 위험 평가 & 대응 전략\n### 기술적 위험\n- **난수 공정성**: 외부 감사 RNG → Seed 기록·검증 API 제공  \n- **성능 병목**: Gacha Service 집중 트래픽 → Fly 레플리카 오토스케일  \n- **보안 취약점**: JWT 탈취, 인앱 해킹 → 2FA 옵션, Code-Obfuscation  \n- **통합 실패**: 결제 Webhook 지연 → 재시도 큐(Redis Streams)  \n- **대응**: Sentry 알림·Circuit Breaker 패턴\n\n### 프로젝트 전달 위험\n- **타임라인**: 외부 라이센스 승인 지연 → 법무 병렬 진행  \n- **리소스**: 모바일 전문 인력 부족 → Capacitor로 웹 인력 전환  \n- **품질**: 테스트 커버리지 80 % 미만 → GitHub Action 실패 시 병합 차단  \n- **배포**: 앱스토어 심사 지연 → PWA 예비 배포  \n- **컨틴전시**: 기능 플래그로 점진적 롤아웃, 블루-그린 배포\n\n",
      "writedAt": "2025-07-07T09:45:16.751Z"
    },
    {
      "type": "guideline",
      "content": "# MTG Gacha 공식 코드 가이드라인\n\n---\n\n## 1. 프로젝트 개요\n\n- **기술 스택 요약**  \n  - 프런트엔드: Next.js 14 (React 18, TypeScript), Capacitor 5, Tailwind CSS  \n  - 백엔드: Node.js 20 (Express, TypeScript), Supabase(PostgreSQL, Auth/Edge Functions), Redis  \n  - 인프라: Vercel, Fly.io, Cloudflare CDN, GitHub Actions CI/CD\n- **주요 아키텍처 결정**  \n  - 도메인 중심(Bounded Context) 폴더 구조  \n  - 계층 분리(presentation, service, repository, infra)  \n  - 핵심 기능별 마이크로서비스(특히 Gacha 엔진)  \n  - Supabase Row-Level Security, JWT 인증, RESTful API  \n  - 코드 일관성 및 품질 확보를 위한 ESLint, Prettier, Husky 적용\n\n---\n\n## 2. 핵심 원칙\n\n1. **일관된 타입 안전성**: 모든 코드에서 TypeScript 타입 명시와 검증 필수\n2. **도메인 분리 및 단일 책임**: 파일·모듈별로 단일 책임 원칙 엄수\n3. **예측 가능한 에러 처리**: 모든 비동기/외부 호출에 명시적 에러 핸들링 적용\n4. **불변성 및 상태 최소화**: 상태는 최소화하고 불변 데이터 패턴 우선\n5. **테스트 가능성 확보**: 함수/컴포넌트는 반드시 테스트 가능하게 설계\n\n---\n\n## 3. 언어별/프레임워크별 가이드\n\n### 3.1. 파일 구성 및 디렉터리 구조\n\n- **MUST**: 도메인 기반 Feature 디렉터리 구조 사용  \n  예시:  \n  ```\n  /apps/web/app/gacha/\n  /apps/web/app/user/\n  /services/gacha-engine/src/gacha/\n  /packages/shared-lib/\n  ```\n\n- **MUST**: 공용 코드/타입/컴포넌트는 `/packages/shared-*`에 위치  \n- **MUST NOT**: 모든 기능을 한 파일 또는 상위 디렉터리에 몰아넣지 말 것\n\n### 3.2. Import 및 의존성 관리\n\n- **MUST**: 상대 경로 대신 절대 경로(예: `@shared-lib/`) 사용\n- **MUST**: 필요 최소한의 외부 라이브러리만 도입\n- **MUST**: Circular Dependency 금지  \n- **MUST NOT**: 디렉터리 경로 하드코딩, 불필요한 import 방치 금지\n\n```typescript\n// MUST: 절대경로 import 예시\nimport { fetchCardMetadata } from '@shared-lib/api/cards';\n```\n\n```typescript\n// MUST NOT: 상대경로, 불필요한 중복 import\nimport fetchCardMetadata from '../../../../shared-lib/api/cards';\n```\n\n### 3.3. 에러 처리 패턴\n\n- **MUST**: 모든 비동기 함수에서 try-catch 사용, 에러는 Sentry 등으로 로깅  \n- **MUST**: 사용자 메시지와 시스템 로그 분리  \n- **MUST**: API/서비스 계층에서만 에러 throw, UI 계층에서는 에러 메시지 변환\n\n```typescript\n// MUST: 명확한 에러 핸들링\ntry {\n  const result = await gachaService.drawPack(userId);\n} catch (error) {\n  logger.error(error); // 시스템 로그\n  throw new ApiError('카드 뽑기 중 오류가 발생했습니다.');\n}\n```\n\n```typescript\n// MUST NOT: 에러 무시, catch 없이 비동기 호출\nconst result = await gachaService.drawPack(userId); // 실패 시 앱 크래시 위험\n```\n\n---\n\n## 4. 코드 스타일 규칙\n\n### 4.1. 반드시 지켜야 할 규칙 (MUST)\n\n- **TypeScript 명시적 타입 선언**  \n  - 함수, 변수, 리턴값 모두 타입 지정  \n  - 이유: 타입 안정성, 자동완성, 유지보수성 강화\n\n- **함수/컴포넌트는 1가지 책임만 갖도록 분리**  \n  - 이유: 테스트 용이성, 재사용성, 코드 가독성 향상\n\n- **React 컴포넌트는 함수형(F.C.)으로 작성, Props 타입 명확히 정의**  \n  - 이유: 일관성, 타입 추론, 리팩토링 용이\n\n- **상태 관리**  \n  - 전역 상태는 React Query/Context만 사용, 필요시 Zustand  \n  - 이유: 예측 가능성, 동기화 문제 최소화\n\n- **비즈니스 로직과 UI 분리**  \n  - 서비스/훅/유틸 함수로 로직 분리  \n  - 이유: 테스트 및 유지보수 용이\n\n- **코드 포맷 자동화**  \n  - Prettier/ESLint 적용, 커밋 전 검사(Husky)\n\n```typescript\n// MUST: 명확한 타입, 단일 책임 함수\ntype Card = { id: string; name: string; rarity: string };\n\nfunction convertToManaPoints(card: Card): number {\n  switch (card.rarity) {\n    case 'mythic': return 100;\n    case 'rare': return 50;\n    default: return 10;\n  }\n}\n```\n\n### 4.2. 절대 해서는 안 되는 규칙 (MUST NOT)\n\n- **여러 도메인/기능을 한 파일에 몰아넣지 말 것**  \n- **복잡한 상태 관리 패턴(예: Redux, MobX 등) 도입 금지**  \n- **any, unknown 타입 남발 금지**  \n- **비동기 호출에서 에러 무시, catch 누락 금지**  \n- **하드코딩된 문자열, 매직넘버 사용 금지**\n\n```typescript\n// MUST NOT: 다중 책임, 타입 미지정, 매직넘버\nfunction handleAll(user, card, payment) {\n  // 카드 변환, 결제 처리, 인벤토리 모두 처리\n  // ...\n}\n\nlet result: any = await fetchData(); // 타입 불명확\n```\n\n---\n\n## 5. 아키텍처 패턴\n\n### 5.1. 컴포넌트/모듈 구조\n\n- **MUST**: 각 도메인(예: gacha, user, payment)별 Feature 디렉터리 분리  \n- **MUST**: presentation → service → repository → infra 계층 구분  \n- **MUST**: 공용 컴포넌트/유틸은 별도 shared 디렉터리 관리\n\n```typescript\n// MUST: 서비스 계층 분리 예시\n// /services/gacha-engine/src/gacha/gachaService.ts\nexport class GachaService {\n  async drawPack(userId: string): Promise<Card[]> {\n    // 난수, 카드풀, 감사로그 등 비즈니스 로직\n  }\n}\n```\n\n### 5.2. 데이터 흐름 및 API 설계\n\n- **MUST**: 클라이언트-서버 통신은 RESTful, JWT 인증 헤더 필수  \n- **MUST**: API 응답은 항상 명확한 status/result/error 구조  \n- **MUST**: 프런트엔드 데이터 패칭은 React Query 활용, 캐시 정책 명확히 설정\n\n```typescript\n// MUST: RESTful API 응답 구조\n{\n  \"status\": \"success\",\n  \"data\": { \"cards\": [...] }\n}\n```\n\n### 5.3. 상태 관리 컨벤션\n\n- **MUST**: 서버 데이터는 React Query, 클라이언트 로컬 상태는 useState/useReducer  \n- **MUST**: 전역 상태 남용 금지, 필요시 Context/Zustand 최소한 사용  \n- **MUST NOT**: Redux/MobX 등 복잡한 상태 관리 도입 금지\n\n```typescript\n// MUST: React Query 데이터 패칭\nconst { data, isLoading } = useQuery(['gachaPack', userId], () => fetchGachaPack(userId));\n```\n\n### 5.4. API 설계 표준\n\n- **MUST**: RESTful URI, 동사 대신 명사 사용  \n- **MUST**: POST/PUT/PATCH/DELETE 등 HTTP 메서드 명확히 구분  \n- **MUST**: 입력/출력 데이터는 Zod 등 스키마로 검증\n\n```typescript\n// MUST: Zod 스키마 검증 예시\nconst DrawPackSchema = z.object({\n  userId: z.string().uuid(),\n  packType: z.enum(['standard', 'premium']),\n});\n```\n\n---\n\n## 6. 코드 예시 및 패턴\n\n### 6.1. 도메인별 파일 구조 예시\n\n```\n/apps/web/app/\n  ├── gacha/\n  │   ├── components/\n  │   ├── hooks/\n  │   ├── services/\n  │   └── pages/\n  ├── user/\n  ├── payment/\n  └── shared/\n```\n\n### 6.2. 올바른 컴포넌트 작성\n\n```typescript\n// MUST: 함수형 컴포넌트, props 타입 명확\ntype GachaResultProps = { cards: Card[] };\n\nconst GachaResult: React.FC<GachaResultProps> = ({ cards }) => (\n  <div>{cards.map(card => <CardItem key={card.id} card={card} />)}</div>\n);\n```\n\n### 6.3. 잘못된 패턴 예시\n\n```typescript\n// MUST NOT: UI, 로직, 상태 혼합, 타입 미정의\nfunction GachaAllInOne(props) {\n  // 카드 뽑기, 포인트 변환, 결제까지 한 컴포넌트에서 처리\n}\n```\n\n### 6.4. 에러 처리 및 로깅\n\n```typescript\n// MUST: Sentry 로깅, 사용자 메시지 분리\ntry {\n  await api.purchasePack(userId, packType);\n} catch (error) {\n  Sentry.captureException(error);\n  setError('구매 중 문제가 발생했습니다.');\n}\n```\n\n---\n\n## 7. 품질 기준\n\n- **테스트 커버리지 80% 이상**  \n- **코드 리뷰 필수, PR 템플릿 준수**  \n- **CI/CD에서 Lint, Build, Test 통과 시만 병합**  \n- **Sentry 등 모니터링 오류 발생 시 신속한 대응**  \n- **보안(OWASP, PCI-DSS, GDPR) 준수 코드만 배포**\n\n---\n\n**본 가이드라인은 MTG Gacha 프로젝트의 모든 코드 작성 및 리뷰에 있어 절대적 기준임을 명시합니다.**",
      "writedAt": "2025-07-07T09:45:16.751Z"
    }
  ]
}