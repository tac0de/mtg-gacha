---
description:
globs:
alwaysApply: true
---
# MTG Gacha 공식 코드 가이드라인

---

## 1. 프로젝트 개요

- **기술 스택 요약**  
  - 프런트엔드: Next.js 14 (React 18, TypeScript), Capacitor 5, Tailwind CSS  
  - 백엔드: Node.js 20 (Express, TypeScript), Supabase(PostgreSQL, Auth/Edge Functions), Redis  
  - 인프라: Vercel, Fly.io, Cloudflare CDN, GitHub Actions CI/CD
- **주요 아키텍처 결정**  
  - 도메인 중심(Bounded Context) 폴더 구조  
  - 계층 분리(presentation, service, repository, infra)  
  - 핵심 기능별 마이크로서비스(특히 Gacha 엔진)  
  - Supabase Row-Level Security, JWT 인증, RESTful API  
  - 코드 일관성 및 품질 확보를 위한 ESLint, Prettier, Husky 적용

---

## 2. 핵심 원칙

1. **일관된 타입 안전성**: 모든 코드에서 TypeScript 타입 명시와 검증 필수
2. **도메인 분리 및 단일 책임**: 파일·모듈별로 단일 책임 원칙 엄수
3. **예측 가능한 에러 처리**: 모든 비동기/외부 호출에 명시적 에러 핸들링 적용
4. **불변성 및 상태 최소화**: 상태는 최소화하고 불변 데이터 패턴 우선
5. **테스트 가능성 확보**: 함수/컴포넌트는 반드시 테스트 가능하게 설계

---

## 3. 언어별/프레임워크별 가이드

### 3.1. 파일 구성 및 디렉터리 구조

- **MUST**: 도메인 기반 Feature 디렉터리 구조 사용  
  예시:  
  ```
  /apps/web/app/gacha/
  /apps/web/app/user/
  /services/gacha-engine/src/gacha/
  /packages/shared-lib/
  ```

- **MUST**: 공용 코드/타입/컴포넌트는 `/packages/shared-*`에 위치  
- **MUST NOT**: 모든 기능을 한 파일 또는 상위 디렉터리에 몰아넣지 말 것

### 3.2. Import 및 의존성 관리

- **MUST**: 상대 경로 대신 절대 경로(예: `@shared-lib/`) 사용
- **MUST**: 필요 최소한의 외부 라이브러리만 도입
- **MUST**: Circular Dependency 금지  
- **MUST NOT**: 디렉터리 경로 하드코딩, 불필요한 import 방치 금지

```typescript
// MUST: 절대경로 import 예시
import { fetchCardMetadata } from '@shared-lib/api/cards';
```

```typescript
// MUST NOT: 상대경로, 불필요한 중복 import
import fetchCardMetadata from '../../../../shared-lib/api/cards';
```

### 3.3. 에러 처리 패턴

- **MUST**: 모든 비동기 함수에서 try-catch 사용, 에러는 Sentry 등으로 로깅  
- **MUST**: 사용자 메시지와 시스템 로그 분리  
- **MUST**: API/서비스 계층에서만 에러 throw, UI 계층에서는 에러 메시지 변환

```typescript
// MUST: 명확한 에러 핸들링
try {
  const result = await gachaService.drawPack(userId);
} catch (error) {
  logger.error(error); // 시스템 로그
  throw new ApiError('카드 뽑기 중 오류가 발생했습니다.');
}
```

```typescript
// MUST NOT: 에러 무시, catch 없이 비동기 호출
const result = await gachaService.drawPack(userId); // 실패 시 앱 크래시 위험
```

---

## 4. 코드 스타일 규칙

### 4.1. 반드시 지켜야 할 규칙 (MUST)

- **TypeScript 명시적 타입 선언**  
  - 함수, 변수, 리턴값 모두 타입 지정  
  - 이유: 타입 안정성, 자동완성, 유지보수성 강화

- **함수/컴포넌트는 1가지 책임만 갖도록 분리**  
  - 이유: 테스트 용이성, 재사용성, 코드 가독성 향상

- **React 컴포넌트는 함수형(F.C.)으로 작성, Props 타입 명확히 정의**  
  - 이유: 일관성, 타입 추론, 리팩토링 용이

- **상태 관리**  
  - 전역 상태는 React Query/Context만 사용, 필요시 Zustand  
  - 이유: 예측 가능성, 동기화 문제 최소화

- **비즈니스 로직과 UI 분리**  
  - 서비스/훅/유틸 함수로 로직 분리  
  - 이유: 테스트 및 유지보수 용이

- **코드 포맷 자동화**  
  - Prettier/ESLint 적용, 커밋 전 검사(Husky)

```typescript
// MUST: 명확한 타입, 단일 책임 함수
type Card = { id: string; name: string; rarity: string };

function convertToManaPoints(card: Card): number {
  switch (card.rarity) {
    case 'mythic': return 100;
    case 'rare': return 50;
    default: return 10;
  }
}
```

### 4.2. 절대 해서는 안 되는 규칙 (MUST NOT)

- **여러 도메인/기능을 한 파일에 몰아넣지 말 것**  
- **복잡한 상태 관리 패턴(예: Redux, MobX 등) 도입 금지**  
- **any, unknown 타입 남발 금지**  
- **비동기 호출에서 에러 무시, catch 누락 금지**  
- **하드코딩된 문자열, 매직넘버 사용 금지**

```typescript
// MUST NOT: 다중 책임, 타입 미지정, 매직넘버
function handleAll(user, card, payment) {
  // 카드 변환, 결제 처리, 인벤토리 모두 처리
  // ...
}

let result: any = await fetchData(); // 타입 불명확
```

---

## 5. 아키텍처 패턴

### 5.1. 컴포넌트/모듈 구조

- **MUST**: 각 도메인(예: gacha, user, payment)별 Feature 디렉터리 분리  
- **MUST**: presentation → service → repository → infra 계층 구분  
- **MUST**: 공용 컴포넌트/유틸은 별도 shared 디렉터리 관리

```typescript
// MUST: 서비스 계층 분리 예시
// /services/gacha-engine/src/gacha/gachaService.ts
export class GachaService {
  async drawPack(userId: string): Promise<Card[]> {
    // 난수, 카드풀, 감사로그 등 비즈니스 로직
  }
}
```

### 5.2. 데이터 흐름 및 API 설계

- **MUST**: 클라이언트-서버 통신은 RESTful, JWT 인증 헤더 필수  
- **MUST**: API 응답은 항상 명확한 status/result/error 구조  
- **MUST**: 프런트엔드 데이터 패칭은 React Query 활용, 캐시 정책 명확히 설정

```typescript
// MUST: RESTful API 응답 구조
{
  "status": "success",
  "data": { "cards": [...] }
}
```

### 5.3. 상태 관리 컨벤션

- **MUST**: 서버 데이터는 React Query, 클라이언트 로컬 상태는 useState/useReducer  
- **MUST**: 전역 상태 남용 금지, 필요시 Context/Zustand 최소한 사용  
- **MUST NOT**: Redux/MobX 등 복잡한 상태 관리 도입 금지

```typescript
// MUST: React Query 데이터 패칭
const { data, isLoading } = useQuery(['gachaPack', userId], () => fetchGachaPack(userId));
```

### 5.4. API 설계 표준

- **MUST**: RESTful URI, 동사 대신 명사 사용  
- **MUST**: POST/PUT/PATCH/DELETE 등 HTTP 메서드 명확히 구분  
- **MUST**: 입력/출력 데이터는 Zod 등 스키마로 검증

```typescript
// MUST: Zod 스키마 검증 예시
const DrawPackSchema = z.object({
  userId: z.string().uuid(),
  packType: z.enum(['standard', 'premium']),
});
```

---

## 6. 코드 예시 및 패턴

### 6.1. 도메인별 파일 구조 예시

```
/apps/web/app/
  ├── gacha/
  │   ├── components/
  │   ├── hooks/
  │   ├── services/
  │   └── pages/
  ├── user/
  ├── payment/
  └── shared/
```

### 6.2. 올바른 컴포넌트 작성

```typescript
// MUST: 함수형 컴포넌트, props 타입 명확
type GachaResultProps = { cards: Card[] };

const GachaResult: React.FC<GachaResultProps> = ({ cards }) => (
  <div>{cards.map(card => <CardItem key={card.id} card={card} />)}</div>
);
```

### 6.3. 잘못된 패턴 예시

```typescript
// MUST NOT: UI, 로직, 상태 혼합, 타입 미정의
function GachaAllInOne(props) {
  // 카드 뽑기, 포인트 변환, 결제까지 한 컴포넌트에서 처리
}
```

### 6.4. 에러 처리 및 로깅

```typescript
// MUST: Sentry 로깅, 사용자 메시지 분리
try {
  await api.purchasePack(userId, packType);
} catch (error) {
  Sentry.captureException(error);
  setError('구매 중 문제가 발생했습니다.');
}
```

---

## 7. 품질 기준

- **테스트 커버리지 80% 이상**  
- **코드 리뷰 필수, PR 템플릿 준수**  
- **CI/CD에서 Lint, Build, Test 통과 시만 병합**  
- **Sentry 등 모니터링 오류 발생 시 신속한 대응**  
- **보안(OWASP, PCI-DSS, GDPR) 준수 코드만 배포**

---

**본 가이드라인은 MTG Gacha 프로젝트의 모든 코드 작성 및 리뷰에 있어 절대적 기준임을 명시합니다.**
